


# Non-Parametric ----

#' Construct a non-parametric bootstrap sample from the provided data, conditional on group structure
#'
#' @param data A data frame. Must contain a variable called `group`.
#'
#' @return A new data frame generated by subsampling independently within each group.
#' @export
#'
#' @examples
#' n = 20
#' K = 3
#' all_reg_pars = make_all_reg_pars()
#' data = make_validation_data(n, K, all_reg_pars)
#'
#' one_non_parametric_sample(data)
one_non_parametric_sample <- function(data){
  new_data = data %>% dplyr::group_by(group) %>%      # Split data into groups
    dplyr::slice_sample(prop = 1, replace = TRUE) %>% # Resample within each group
    dplyr::ungroup()                                  # Remove grouping structure
  return(new_data)
}








# Parametric ----


#' Generate a parametric bootstrap sample using the provided fitted models
#'
#' @param mod_Y A model fit using `glmer` to predict `Y`
#' @param mod_M A model fit using `glmer` to predict `M`
#'
#' @return A data frame obtained by generating bootstrap samples independently across groups.
#' @export
#'
#' @examples
#' n = 20
#' K = 3
#' all_reg_pars = make_all_reg_pars()
#' data = make_validation_data(n, K, all_reg_pars)
#'
#' mod_Y = fit_mod_Y(data)
#' mod_M = fit_mod_M(data)
#'
#' one_parametric_resample(mod_Y, mod_M)
one_parametric_resample <- function(mod_Y, mod_M){
  data = mod_Y@frame
  warning("Using @frame to access the data may break when interactions are included.")

  # Extract relevant parameters
  all_reg_pars = all_reg_pars_from_lme4(mod_Y, mod_M)

  # Split data by group
  data_list = split(data, data$group)

  # Overwrite M and Y within each group
  for(k in seq_along(data_list)){
    data_list[[k]] %<>% replace_M(all_reg_pars) %>%
      replace_Y(all_reg_pars)
  }

  # Re-combine groups into a single data.frame
  data_new = purrr::list_rbind(data_list)

  # Convert group variable from factor back to character
  data_new %<>% dplyr::mutate_if(is.factor, as.character)
  # data_new$group = as.character(data_new$group)
  return(data_new)
}


all_reg_pars_from_lme4 <- function(mod_Y, mod_M){
  beta_Y = lme4::fixef(mod_Y)
  beta_M = lme4::fixef(mod_M)

  sqrt_Gamma_Y = as.matrix(lme4::getME(mod_Y, "Lambda")[1:3, 1:3])
  sqrt_Gamma_M = as.matrix(lme4::getME(mod_M, "Lambda")[1:2, 1:2])

  Gamma_Y = sqrt_Gamma_Y %*% t(sqrt_Gamma_Y)
  Gamma_M = sqrt_Gamma_M %*% t(sqrt_Gamma_M)

  make_all_reg_pars(beta_Y, Gamma_Y, beta_M, Gamma_M)
}


replace_M <- function(data, all_reg_pars){
  # Extract relevant variables
  X = data$X
  all_Cs = dplyr::select(data, -Y, -M, -X, -group)

  # Generate M
  new_M = make_M_validation(X, all_Cs, all_reg_pars)

  # Overwrite old M
  data$M = new_M
  return(data)
}


replace_Y <- function(data, all_reg_pars){
  # Extract relevant variables
  M = data$M
  X = data$X
  all_Cs = dplyr::select(data, -Y, -M, -X, -group)

  # Generate Y
  new_Y = make_Y_validation(M, X, all_Cs, all_reg_pars)

  # Overwrite old Y
  data$Y = new_Y
  return(data)
}


