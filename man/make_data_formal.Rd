% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Fit_Regression_Models.R
\name{make_data_formal}
\alias{make_data_formal}
\title{Transform \code{data} into a formal data frame}
\usage{
make_data_formal(
  data,
  Y_name = NULL,
  M_name = NULL,
  X_name = NULL,
  group_name = NULL
)
}
\arguments{
\item{data}{A data frame containing the outcome, mediator, exposure and group variables. May also contain other columns, which are assumed to be confounders.}

\item{Y_name}{Name of the outcome variable in \code{data}. This column name will be converted to \code{Y}.}

\item{M_name}{Name of the mediator variable in \code{data}. This column name will be converted to \code{M}.}

\item{X_name}{Name of the exposure variable in \code{data}. This column name will be converted to \code{X}.}

\item{group_name}{Name of the group variable in \code{data}. This column name will be converted to \code{group}.}
}
\value{
A formal data frame. See Details.
}
\description{
Transform \code{data} into a formal data frame
}
\details{
I make strong assumptions about the structure of the data frame which is passed to this function. Such a structured data frame is referred to as \code{data_formal}. The requirements are as follows:
\itemize{
\item Must contain columns named Y, M, X and group
\item May also contain other columns. Each such extra column must be a confounder.      !!!! I'm not sure yet whether I want to require that these columns be named C1, C2, ...
\item Groups must be labelled G1, G2, ...
\item Must be sorted by group label
}
}
\examples{
B = 2
n = 20
K = 3
all_reg_pars = make_all_reg_pars()
data = make_validation_data(n, K, all_reg_pars)

# Pollute the data
data_new = data \%>\%
 rbind(data.frame(Y = 1, M=1, X=1, C1=1, C2=1, group="group_4"), .) \%>\%  # Add a fourth group with an incompatible name
 dplyr::rename(Y_alt = "Y")                                              # Change the name of Y

 make_data_formal(data_new, Y_name = "Y_alt", M_name = "M", X_name = "X", group_name = "group")
}
